{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Svg } from 'layercake';\n  import { scaleBand } from 'd3-scale';\n\n  import fruit from './data/fruitOrdinal.csv';\n  import ClevelandDotPlot from './components/ClevelandDotPlot.svelte';\n  import AxisX from './components/AxisX.svelte';\n  import AxisYScaleBand from './components/AxisYScaleBand.svelte';\n\n  const seriesColors = ['#f0c', '#00bbff', '#00e047', '#ff7a33'];\n\n  const seriesNames = Object.keys(fruit[0]).filter(d => d !== 'year');\n\n  fruit.forEach(row => {\n    seriesNames.forEach(name => {\n      row[name] = +row[name];\n    });\n  });\n</script>\n\n<style>\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ right: 10, bottom: 20, left: 30 }}\n    x={['apples', 'bananas', 'cherries', 'dates']}\n    y={'year'}\n    yScale={scaleBand().paddingInner([0.05]).round(true)}\n    yDomain={['2016', '2017', '2018', '2019']}\n    xDomain={[0, null]}\n    xPadding={[10, 0]}\n    data={fruit}\n  >\n    <Svg>\n      <AxisX/>\n      <AxisYScaleBand\n        gridlines={false}\n      />\n      <ClevelandDotPlot\n        {seriesColors}\n      />\n    </Svg>\n  </LayerCake>\n\n</div>"},"dek":"You could create this kind of plot by reshaping your data into rows of containing `name`, `value` and `group` and plot it like a scatter plot, but here's another way that doesn't require all that data manipulation and takes advantage of Layer Cake's accessor shorthand. In `main.js`, we simply specify the names of the keys in each row that we want to plot and in the layer component, we call `$xGet(row)` to map each object into an array of pixel values.\n","components":[{"title":"./components/ClevelandDotPlot.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n  import { scaleOrdinal } from 'd3-scale';\n\n  const { data, xGet, yGet, yScale, originalSettings } = getContext('LayerCake');\n\n  export let seriesColors;\n\n  $: midHeight = $yScale.bandwidth() / 2;\n\n  $: colorScale = scaleOrdinal()\n    .domain($originalSettings.x)\n    .range(seriesColors);\n\n</script>\n\n<g class=\"dot-group\">\n  {#each $data as row}\n    <g>\n      <line\n        x1=\"{Math.min(...$xGet(row))}\"\n        y1=\"{$yGet(row) + midHeight}\"\n        x2=\"{Math.max(...$xGet(row))}\"\n        y2=\"{$yGet(row) + midHeight}\"\n      ></line>\n\n      {#each $xGet(row) as circleX, i}\n        <circle\n          cx=\"{circleX}\"\n          cy=\"{$yGet(row) + midHeight}\"\n          r=\"5\"\n          fill=\"{colorScale($originalSettings.x[i])}\"\n        ></circle>\n      {/each}\n    </g>\n  {/each}\n</g>\n\n<style>\n  line {\n    stroke-width: 1px;\n    stroke: #000;\n  }\n  circle {\n    stroke: #000;\n    stroke-width: 1px;\n  }\n</style>"},{"title":"./components/AxisX.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yScale } = getContext('LayerCake');\n\n\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let ticks = undefined;\n  export let tickX = '0';\n  export let tickY = '16';\n  export let tickDx = '0';\n  export let tickDy = '0';\n\n  let tickVals;\n\n  $: if (typeof $xScale.bandwidth === 'function') {\n    tickVals = $xScale.domain();\n  } else if (Array.isArray(ticks)) {\n    tickVals = ticks;\n  } else {\n    tickVals = $xScale.ticks(ticks);\n  }\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis'>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text\n        x={typeof tickX === 'function' ? tickX($xScale) : tickX}\n        y={typeof tickY === 'function' ? tickY($yScale) : tickY}\n        dx='{typeof tickDx === 'function' ? tickDx($xScale) : typeof $xScale.bandwidth === 'function' ? ($xScale.bandwidth() / 2) : tickDx}'\n        dy='{typeof tickDy === 'function' ? tickDy($yScale) : tickDy}'\n        text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/AxisYScaleBand.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { xScale, yScale, xRange } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let formatTick = d => d;\n\n  $: halfBandwidth = $yScale.bandwidth() / 2;\n</script>\n\n<g class='axis y-axis'>\n  {#each $yScale.domain() as tick}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0]}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line x2='100%' y1={halfBandwidth} y2={halfBandwidth}></line>\n      {/if}\n      <text y='{4 + halfBandwidth}' x=\"-5\">{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n\n  .y-axis .tick text {\n    text-anchor: end;\n  }\n</style>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./data/fruitOrdinal.csv","contents":"year,apples,bananas,cherries,dates\n2019,3840,1920,960,400\n2018,1600,1440,960,400\n2017,820,1000,640,400\n2016,820,560,720,400"}]}