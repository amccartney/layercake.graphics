{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Svg, Html } from 'layercake';\n  import { scaleOrdinal } from 'd3-scale';\n  import { timeParse, timeFormat } from 'd3-time-format';\n\n  import data from './data/fruit.csv';\n  import MultiLine from './components/MultiLine.svelte';\n  import AxisX from './components/AxisX.svelte';\n  import AxisY from './components/AxisY.svelte';\n  import Labels from './components/Labels.svelte';\n  import Tooltip from './components/Tooltip.svelte';\n\n  /* --------------------------------------------\n   * Set what is our x key to separate it from the other series\n   */\n  const xKey = 'month';\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = [\n    '#ffe4b8',\n    '#ffb3c0',\n    '#ff7ac7',\n    '#ff00cc'\n  ];\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  const dataLong = seriesNames.map(key => {\n    return {\n      key,\n      values: data.map(d => {\n        const obj = { key, value: +d[key] };\n        obj[xKey] = parseDate(d[xKey]);\n        return obj;\n      })\n    };\n  })\n\n  // Make a flat array of the `values` of our nested series\n  // we can pluck the `value` field from each item in the array to measure extents\n  const flatten = data => data.reduce((memo, group) => memo.concat(group.values), []);\n\n  const colorScale = scaleOrdinal()\n    .domain(seriesNames)\n    .range(seriesColors);\n\n  const formatTickX = timeFormat('%b. %e');\n\n  function formatTickY (d) {\n    if (d > 999) {\n      return d / 1000 + 'k';\n    }\n    return d;\n  }\n</script>\n\n<style>\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 7, right: 10, bottom: 20, left: 25 }}\n    x={xKey}\n    y='value'\n    flatData={flatten(dataLong)}\n    yDomain={[0, null]}\n    data={dataLong}\n  >\n    <Svg>\n      <AxisX\n        gridlines={false}\n        ticks={data.map(d => parseDate(d[xKey])).sort((a, b) => a - b)}\n        formatTick={formatTickX}\n        snapTicks={true}\n      />\n      <AxisY\n        ticks={4}\n        formatTick={formatTickY}\n      />\n\n      <MultiLine\n        {colorScale}\n      />\n    </Svg>\n\n    <Html>\n      <Labels/>\n      <Tooltip\n        dataset={ data }\n      />\n    </Html>\n  </LayerCake>\n</div>"},"dek":"A multiline example with a quadtree tooltip.\n","components":[{"title":"./components/MultiLine.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, xScale, yScale, xDomain, yDomain } = getContext('LayerCake');\n\n  export let colorScale = d => '#000';\n\n  $: path = values => {\n    return 'M' + values\n      .map(d => {\n        return $xGet(d) + ',' + $yGet(d);\n      })\n      .join('L');\n  };\n</script>\n\n<g class=\"line-group\">\n  {#each $data as group}\n    <path\n      class='path-line'\n      d='{path(group.values)}'\n      stroke=\"{colorScale(group.key)}\"\n    ></path>\n  {/each}\n</g>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./components/AxisX.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yScale } = getContext('LayerCake');\n\n\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let ticks = undefined;\n  export let tickX = '0';\n  export let tickY = '16';\n  export let tickDx = '0';\n  export let tickDy = '0';\n\n  let tickVals;\n\n  $: if (typeof $xScale.bandwidth === 'function') {\n    tickVals = $xScale.domain();\n  } else if (Array.isArray(ticks)) {\n    tickVals = ticks;\n  } else {\n    tickVals = $xScale.ticks(ticks);\n  }\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis'>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text\n        x={typeof tickX === 'function' ? tickX($xScale) : tickX}\n        y={typeof tickY === 'function' ? tickY($yScale) : tickY}\n        dx='{typeof tickDx === 'function' ? tickDx($xScale) : typeof $xScale.bandwidth === 'function' ? ($xScale.bandwidth() / 2) : tickDx}'\n        dy='{typeof tickDy === 'function' ? tickDy($yScale) : tickDy}'\n        text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/AxisY.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, xScale, yScale } = getContext('LayerCake');\n\n  export let ticks = undefined;\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let tickX = '0';\n  export let tickY = '';\n  export let tickDx = undefined;\n  export let tickDy = undefined;\n  export let textAnchor = typeof $yScale.bandwidth === 'function'  ? 'end' : 'start';\n\n  let tickVals;\n\n  $: if (typeof $yScale.bandwidth === 'function') {\n    tickVals = $yScale.domain();\n  } else if (Array.isArray(ticks)) {\n    tickVals = ticks;\n  } else {\n    tickVals = $yScale.ticks(ticks);\n  }\n</script>\n\n<g class='axis y-axis' transform='translate(-{$padding.left}, 0)'>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0]}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line\n          x2='100%'\n          y1=\"{typeof tickY === 'function' ? tickY($yScale) : typeof tickY === 'undefined' && typeof $yScale.bandwidth === 'function' ? ($yScale.bandwidth() / 2) : tickY || '-4'}\"\n          y2=\"{typeof tickY === 'function' ? tickY($yScale) : typeof tickY === 'undefined' && typeof $yScale.bandwidth === 'function' ? ($yScale.bandwidth() / 2) : tickY || '-4'}\"\n        ></line>\n      {/if}\n      <text\n        x='{typeof tickX === 'function' ? tickX($xScale) : typeof tickX === 'undefined' && typeof $yScale.bandwidth === 'function' ? '-5' : tickX || '0'}'\n        y='{typeof tickY === 'function' ? tickY($yScale) : typeof tickY === 'undefined' && typeof $yScale.bandwidth === 'function' ? (4 + ($yScale.bandwidth() / 2)) : tickY || '-4'}'\n        dx={typeof tickDx === 'function' ? tickDx($xScale) : tickDx}\n        dy={typeof tickDy === 'function' ? tickDy($yScale) : tickDy}\n        style=\"text-anchor:{textAnchor};\"\n      >{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/Labels.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { data, x, xGet, yGet } = getContext('LayerCake');\n\n  function pretty (val) {\n    return val.charAt(0).toUpperCase() + val.slice(1, val.length);\n  }\n\n  // Get the data for the last row (highest x-value)\n  $: max = values => {\n    let d;\n    let m = -Infinity;\n    let i = 0;\n    while (i < values.length) {\n      const val = $x(values[i]);\n      if (val > m) {\n        m = val;\n        d = values[i];\n      }\n      i += 1;\n    }\n    return d;\n  }\n\n  $: left = values => $xGet(max(values));\n  $: top = values => $yGet(max(values));\n</script>\n\n{#each $data as group}\n  <div\n    class=\"label\"\n    style=\"top:{top(group.values)}px;left:{left(group.values)}px;\"\n  >{pretty(group.key)}</div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%)translateY(1px);\n    font-size: 13px;\n  }\n</style>"},{"title":"./components/Tooltip.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  import QuadTree from './QuadTree.svelte';\n\n  const { width, yScale, originalSettings } = getContext('LayerCake');\n\n  export let dataset;\n\n  const w = 150;\n  const w2 = w / 2;\n  let top = 0;\n\n  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n\n  function capitalize (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1, str.length);\n  }\n\n  function addCommas (num) {\n    const parts = String(num).split('.');\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n    return parts.join('.');\n  }\n\n  let contents = '';\n\n  function setContents (result) {\n    if (Object.keys(result).length === 0) return '';\n    const rows = Object.keys(result).filter(d => d !== $originalSettings.x).map(key => {\n      return {\n        key,\n        value: result[key]\n      };\n    }).sort((a, b) => b.value - a.value);\n\n    top = $yScale(rows[0].value) - 20;\n\n    return `\n      <div style=\"font-weight: bold;\">${monthNames[result[$originalSettings.x].getUTCMonth()]} ${result[$originalSettings.x].getUTCDate()}</div>\n      ${rows.map(row => `<div><span style=\"color: #999; width: 65px;display:inline-block;\">${capitalize(row.key)}:</span> ${addCommas(row.value)}</div>`).join('')}`;\n  }\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    font-size: 13px;\n    pointer-events: none;\n    border: 1px solid #ccc;\n    background: rgba(255, 255, 255, 0.85);\n    transform: translate(-50%, -100%);\n    padding: 5px;\n    transition: left 250ms ease-out, top 250ms ease-out;\n    z-index: 15;\n  }\n</style>\n\n<QuadTree\n  {dataset}\n  y='x'\n  let:x\n  let:y\n  let:visible\n  let:found\n  let:e\n>\n  <div\n    class=\"tooltip\"\n    style=\"width:{w}px;display: { visible ? 'block' : 'none' };top:{top}px;left:{Math.min(Math.max(w2, x), $width - w2)}px;\">{@html setContents(found)}</div>\n</QuadTree>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./components/QuadTree.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  export let dataset = undefined;\n  export let x = 'x';\n  export let y = 'y';\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem (evt) {\n    e = evt;\n    found = finder.find(evt[`layer${x.toUpperCase()}`], evt[`layer${y.toUpperCase()}`], 300) || {};\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([[-1, -1], [$width + 1, $height + 1]])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n\n</script>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>\n\n<div\n  class=\"bg\"\n  on:mousemove=\"{findItem}\"\n  on:mouseout=\"{() => visible = false}\"\n></div>\n<slot\n  x={xGetter(found) || 0}\n  y={yGetter(found) || 0}\n  {found}\n  {visible}\n  {e}\n></slot>"}],"csvs":[{"title":"./data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}]}